#include <common/net/message/nodes/SetMirrorBuddyGroupMsg.h>
#include <common/net/message/nodes/SetMirrorBuddyGroupRespMsg.h>
#include <common/storage/StorageTargetInfo.h>
#include <common/toolkit/MessagingTk.h>
#include <common/toolkit/NodesTk.h>
#include <common/toolkit/ZipIterator.h>

#include "MirrorBuddyGroupCreator.h"


/**
 * @return FhgfsOpsErr_...
 */
FhgfsOpsErr MirrorBuddyGroupCreator::addGroup(uint16_t primaryTargetID, uint16_t secondaryTargetID,
   uint16_t forcedGroupID)
{
   LogContext log = LogContext("MirrorBuddyGroupCreator (addGroup)");

   FhgfsOpsErr retVal = FhgfsOpsErr_INTERNAL;

   // disallow meta buddy group creation if the selected secondary target would have the root inode,
   // not the primary. while we could copy the root inode from secondary to primary, forcing the
   // non-mirrored root inode owner to be the primary of a group is much less error-prone.
   if (nodeType == NODETYPE_Meta && secondaryTargetID == metaNodes->getRootNodeNumID().val())
      return FhgfsOpsErr_NOTOWNER;

   uint16_t newGroupID;
   FhgfsOpsErr addRes = addGroupComm(primaryTargetID, secondaryTargetID, forcedGroupID, newGroupID);

   if (addRes != FhgfsOpsErr_SUCCESS)
   {
      std::string errStr;

      if (addRes == FhgfsOpsErr_INUSE)
         errStr = "One of the targets is already mapped to a buddy group.";
      else
      if (addRes == FhgfsOpsErr_UNKNOWNTARGET)
         errStr = FhgfsOpsErrTk::toErrString(addRes);
      else
      if (addRes == FhgfsOpsErr_EXISTS)
         errStr = "Mirror buddy group with ID " + StringTk::uintToStr(forcedGroupID)
            + " already exists.";
      else
         errStr = "Internal error.";

      std::string logMessage("Failed to add mirror buddy group: primaryTargetID " +
         StringTk::uintToStr(primaryTargetID) + "; secondaryTargetID " +
         StringTk::uintToStr(secondaryTargetID) + "; Error: " + errStr);
      std::cerr << logMessage << std::endl;
      log.logErr(logMessage);
   }
   else
   {
      std::string logMessage("Mirror buddy group successfully set: groupID " +
         StringTk::uintToStr(newGroupID) + " -> target IDs " +
         StringTk::uintToStr(primaryTargetID) + ", " + StringTk::uintToStr(secondaryTargetID) );
      std::cout << logMessage << std::endl;
      log.log(Log_NOTICE, logMessage);

      retVal = FhgfsOpsErr_SUCCESS;
   }

   return retVal;
}

/*
 * @param forcedGroupID 0 means create new group, otherwise create group with that ID
 * @param outNewGroupID will be set by response message; will have the generated ID of a newly
 *    created group or the old group ID if a group was changed
 * @return FhgfsOpsErr_...
 */
FhgfsOpsErr MirrorBuddyGroupCreator::addGroupComm(uint16_t primaryID, uint16_t secondaryID,
   uint16_t forcedGroupID, uint16_t& outNewGroupID)
{
   FhgfsOpsErr retVal = FhgfsOpsErr_INTERNAL;

   auto mgmtNode = this->mgmtNodes->referenceFirstNode();

   bool commRes;
   char* respBuf = NULL;
   NetMessage* respMsg = NULL;
   SetMirrorBuddyGroupRespMsg* respMsgCast;

   SetMirrorBuddyGroupMsg msg(this->nodeType, primaryID, secondaryID, forcedGroupID, false);

   // request/response
   commRes = MessagingTk::requestResponse(
      *mgmtNode, &msg, NETMSGTYPE_SetMirrorBuddyGroupResp, &respBuf, &respMsg);
   if(!commRes)
   {
      retVal = FhgfsOpsErr_COMMUNICATION;
      goto err_cleanup;
   }

   respMsgCast = (SetMirrorBuddyGroupRespMsg*)respMsg;

   retVal = (FhgfsOpsErr)respMsgCast->getResult();

   if (forcedGroupID != 0)
      outNewGroupID = forcedGroupID;
   else
      outNewGroupID = respMsgCast->getBuddyGroupID();

err_cleanup:
   SAFE_DELETE(respMsg);
   SAFE_FREE(respBuf);

   return retVal;
}

/**
 * Create all MirrorBuddyGroups which was generated by the automatic mode
 *
 * @param retValGeneration the return value of the MirrorBuddyGroup generation
 * @param buddyGroupIDs A list with all MirrorBuddyGroupIDs to create
 * @param buddyGroups A list with all MirrorBuddyGroups to create
 * @return true if all MirrorBuddyGroups created successful, false if not
 */
bool MirrorBuddyGroupCreator::createMirrorBuddyGroups(FhgfsOpsErr retValGeneration,
   UInt16List* buddyGroupIDs, MirrorBuddyGroupList* buddyGroups)
{
   if( (retValGeneration == FhgfsOpsErr_SUCCESS) ||
      ( (retValGeneration == FhgfsOpsErr_INVAL) && this->cfgForce) )
   { // create the MirrorBuddyGroup
      if(!this->cfgDryrun)
      { // but only when it is not a dryrun
         for (ZipIterRange<UInt16List, MirrorBuddyGroupList> iter(*buddyGroupIDs, *buddyGroups);
              !iter.empty(); ++iter)
         {
            FhgfsOpsErr retValAddGroup = addGroup((iter()->second)->firstTargetID,
               (iter()->second)->secondTargetID, *(iter()->first) );

            if(retValAddGroup != FhgfsOpsErr_SUCCESS)
               return false;
         }
      }
   }

   return true;
}

/**
 * Removes all nodes / targets from the node ID list which are part of a mirror buddy group.
 *
 * @param oldPrimaryIDs PrimaryTargetIDs from existing MirrorBuddyGroups
 * @param oldSecondaryIDs SecondaryTargetIDs from existing MirrorBuddyGroups
 * @return true if all targets successful removed from TargetMapper, false on error
 */
bool MirrorBuddyGroupCreator::removeTargetsFromExistingMirrorBuddyGroups(UInt16List* oldPrimaryIDs,
   UInt16List* oldSecondaryIDs)
{
   bool retVal = true;

   for (ZipIterRange<UInt16List, UInt16List> primSecIDIter(*oldPrimaryIDs, *oldSecondaryIDs);
        !primSecIDIter.empty(); ++primSecIDIter)
   {
      retVal = retVal && this->localTargetMapper.unmapTarget(*(primSecIDIter()->first));
      retVal = retVal && this->localTargetMapper.unmapTarget(*(primSecIDIter()->second));
   }

   return retVal;
}

/**
 * Find the TargetNumID of the next target which should be used for a MirrorBuddyGroup. A target
 * from the storage server with the most targets will be selected. It is possible to ignore the
 * targets of a storage server. The selected target is removed from the given TargetMapper.
 *
 * @param nodeNumIdToIgnore The NodeNumID to ignore in the search or 0 to disable the ignore feature
 * @return the TargetNumID to use or 0 if no target found
 */
uint16_t MirrorBuddyGroupCreator::findNextTarget(NumNodeID nodeNumIdToIgnore)
{
   uint16_t retVal = 0;

   size_t maxNumTargets = 0;

   auto node = this->nodes->referenceFirstNode();
   while (node != NULL)
   {
      if (node->getNumID() == nodeNumIdToIgnore)
      {
         node = this->nodes->referenceNextNode(node);
         continue;
      }

      UInt16List targetList;
      this->localTargetMapper.getTargetsByNode(node->getNumID(), targetList);

      if(targetList.size() > maxNumTargets)
      {
         maxNumTargets = targetList.size();
         retVal = targetList.front();
      }
      node = this->nodes->referenceNextNode(node);
   }

   this->localTargetMapper.unmapTarget(retVal);

   return retVal;
}

uint16_t MirrorBuddyGroupCreator::generateID(UInt16List* usedMirrorBuddyGroups)
{
   const std::set<uint16_t> used(usedMirrorBuddyGroups->begin(), usedMirrorBuddyGroups->end());

   struct ops
   {
      static bool hasGap(uint16_t a, uint16_t b)
      {
         return a + 1 < b;
      }
   };

   if (used.empty())
      return 1;

   if (*used.rbegin() < 0xFFFF)
      return *used.rbegin() + 1;

   if (*used.begin() > 1)
      return 1;

   const auto gap = std::adjacent_find(used.begin(), used.end(), ops::hasGap);
   if (gap != used.end())
      return *gap + 1;

   return 0;
}

uint16_t MirrorBuddyGroupCreator::generateUniqueID(TargetMapper* targetMapper,
   UInt16List* usedMirrorBuddyGroups)
{
   uint16_t newGroupID = 1;

   // search if the selected ID is in use
   bool idFound = false;
   UInt16ListIter groupIter = usedMirrorBuddyGroups->begin();
   for( ; groupIter !=  usedMirrorBuddyGroups->end(); groupIter++)
   {
      if(*groupIter == newGroupID)
      {
         idFound = true;
         break;
      }
   }

   if (idFound || (targetMapper && targetMapper->getNodeID(newGroupID) ) )
   {
      /*selected ID is in use already, so walk from there to find the next free ID. */
      for ( ;; )
      {
         newGroupID++;

         // check range... (avoid reserved value "0" as newNumID)
         if ( unlikely(!newGroupID || (newGroupID > MIRRORBUDDYGROUPMAPPER_MAX_GROUPIDS) ) )
         {
            newGroupID = 0;
            break;
         }

         // search if the selected ID is in use
         idFound = false;
         groupIter = usedMirrorBuddyGroups->begin();
         for( ; groupIter !=  usedMirrorBuddyGroups->end(); groupIter++)
         {
            if(*groupIter == newGroupID)
            {
               idFound = true;
               break;
            }
         }

         if (!idFound && targetMapper && !targetMapper->getNodeID(newGroupID))
            return newGroupID; // we found an ID that no other node uses
      }
   }

   return newGroupID;
}

/**
 * Check the size of the targets and prints a warning to the console if the size of all targets is
 * not equal.
 *
 * @param mapper TargetMapper with all storage targets of the system. For checking metadata nodes,
 *               the mapper just needs to contain the correct node IDs, the target IDs are not
 *               relevant (since metanodes can't have multiple targets)
 * @return false if the targets have a different size or a error occurred,
 *    true if all targets have the same size
 */
bool MirrorBuddyGroupCreator::checkSizeOfTargets()
{
   LogContext log = LogContext("MirrorBuddyGroupCreator (checkSizeOfTargets)");

   bool retVal = true;

   int64_t spaceValue = 0;


   // Retrieve the statStoragePath information from all storage servers
   auto node = this->nodes->referenceFirstNode();
   while (node && retVal)
   {
      UInt16List targets;
      this->systemTargetMapper.getTargetsByNode(node->getNumID(), targets);

      // Retrieve the statStoragePath information from the storage server
      for(UInt16ListIter targetIter = targets.begin(); targetIter != targets.end(); targetIter++)
      {
         int64_t freeSpace;
         int64_t totalSpace;
         int64_t freeInodes;
         int64_t totalInodes;

         FhgfsOpsErr statRes = StorageTargetInfo::statStoragePath(*node, *targetIter, &freeSpace,
            &totalSpace, &freeInodes, &totalInodes);
         if(statRes != FhgfsOpsErr_SUCCESS)
         {
            std::string logMessage("An error occurred when connecting to server: "
               + node->getNodeIDWithTypeStr() + " Error: " + FhgfsOpsErrTk::toErrString(statRes) );
            std::cerr << logMessage << std::endl;
            log.logErr(logMessage);

            return false;
         }

         if(spaceValue == 0) // check of the first target
            spaceValue = totalSpace;
         else
         if(spaceValue != totalSpace)
         {
            retVal = false;
            break;
         }
      }

      if (retVal)
         node = this->nodes->referenceNextNode(node);
   }

   // report a warning, because the size of all targets is not equal
   if(!retVal)
   {
      std::string logMessage("Target size differs. Automatic mode does not take this into account. "
         "It is recommended that all storage targets have the same size when using automatic mode."
         );
      std::cout << "[WARNING] " << logMessage << std::endl;
      log.log(Log_WARNING, logMessage);
   }

   return retVal;
}

/**
 * Checks which of the both targets is the best choice for the primary target. The storage server
 * with the lower primary target count is the best choice.
 *
 * @param primaryUsed A map with NodeNumIDs to counter of primary targets
 * @param inOutPrimaryID In/Out value for the primary Target/NodeNumID
 * @param inOutSecondaryID In/Out value for the secondary Target/NodeNumID
 */
void MirrorBuddyGroupCreator::selectPrimaryTarget(PrimaryTargetCounterMap* primaryUsed,
   uint16_t* inOutPrimaryID, uint16_t* inOutSecondaryID)
{
   NumNodeID primaryServerNumID = this->systemTargetMapper.getNodeID(*inOutPrimaryID);
   NumNodeID secondaryServerNumID = this->systemTargetMapper.getNodeID(*inOutSecondaryID);

   size_t primaryServerCounter = (*primaryUsed)[primaryServerNumID];
   size_t secondaryServerCounter = (*primaryUsed)[secondaryServerNumID];

   if(primaryServerCounter > secondaryServerCounter)
   {
      uint16_t tmpID = *inOutPrimaryID;
      *inOutPrimaryID = *inOutSecondaryID;
      *inOutSecondaryID = tmpID;

      (*primaryUsed)[secondaryServerNumID]++;
   }
   else
      (*primaryUsed)[primaryServerNumID]++;
}

/**
 * Generates MirrorBuddyGroups with the given targets, but do not create the MirrorBuddyGroups on
 * the management daemon
 *
 * @param outBuddyGroupIDs A list with all new selected MirrorBuddyGroupIDs
 * @param outBuddyGroups A list with all new selected MirrorBuddyGroups
 * @param usedMirrorBuddyGroupIDs A list with used MirrorBuddyGroupIDs
 * @return FhgfsOpsErr_SUCCESS when the selected MirrorBuddyGroups does not hurt any constraint,
 *    FhgfsOpsErr_INVAL at least one constraint is hurt, on error FhgfsOpsErr_...
 */
FhgfsOpsErr MirrorBuddyGroupCreator::generateMirrorBuddyGroups(UInt16List* outBuddyGroupIDs,
   MirrorBuddyGroupList* outBuddyGroups, UInt16List* usedMirrorBuddyGroupIDs)
{
   LogContext log = LogContext("MirrorBuddyGroupCreator (generateMirrorBuddyGroups)");

   FhgfsOpsErr retVal = FhgfsOpsErr_SUCCESS;

   size_t numTargets = this->localTargetMapper.getSize();
   if(numTargets == 0)
   { // check if unused targets exists
      std::string logMessage(
         "No targets without a mirror group found. Mirror groups have not been changed.");
      std::cout << logMessage << std::endl;
      log.logErr(logMessage);

      return FhgfsOpsErr_INTERNAL;
   }

   if(numTargets % 2 != 0)
   { // check for even number of targets
      std::string logMessage(
         "Odd number of targets detected. One target left without a mirror group.");
      std::cout << "[WARNING] " << logMessage << std::endl;
      log.log(Log_WARNING, logMessage);

      retVal = FhgfsOpsErr_INVAL;
   }

   // check if all targets have the same size
   if(!checkSizeOfTargets() )
      retVal = FhgfsOpsErr_INVAL;

   // create a black list of MirrorBuddyGroupIDs, used MirrorBuddyGroupIDs + new MirrorBuddyGroupIDs
   UInt16List blackListGroupIDs;
   blackListGroupIDs.insert(blackListGroupIDs.begin(), usedMirrorBuddyGroupIDs->begin(),
      usedMirrorBuddyGroupIDs->end() );

   PrimaryTargetCounterMap primaryTargetCounter;

   while(numTargets > 1)
   { // requires at least two targets for a BuddyMirrorGroup
      uint16_t mirrorBuddyGroupID = 0;
      uint16_t primaryTarget = findNextTarget(NumNodeID(0) );
      NumNodeID ignoreID = this->systemTargetMapper.getNodeID(primaryTarget);
      uint16_t secondaryTarget = findNextTarget(ignoreID);

      if(secondaryTarget)
      { // second target on a different server found ==> good case
         // TODO does not have to be done for meta nodes since Node=Target.
         selectPrimaryTarget(&primaryTargetCounter, &primaryTarget, &secondaryTarget);
      }
      else
      { // all targets are located on the same server ==> bad case
         secondaryTarget = findNextTarget(NumNodeID(0) );
         if(!secondaryTarget)
         {
            std::string logMessage("No second target for mirror group found.");
            std::cout << logMessage << std::endl;
            log.logErr(logMessage);

            return FhgfsOpsErr_INTERNAL;
         }
         std::string logMessage("Created " +
            StringTk::uintToStr(mirrorBuddyGroupID) + " with targets " +
            StringTk::uintToStr(primaryTarget) + " and " + StringTk::uintToStr(secondaryTarget) +
            ", but both targets are located on the same server.");
         std::cout << "[WARNING] " << logMessage << std::endl;
         log.log(Log_WARNING, logMessage);

         retVal = FhgfsOpsErr_INVAL;
      }

      // if we have selected the owner of the root inode as secondary, just switch primary and
      // secondary to fix that.
      if (nodeType == NODETYPE_Meta && secondaryTarget == metaNodes->getRootNodeNumID().val())
         std::swap(primaryTarget, secondaryTarget);

      if (this->cfgUnique)
         mirrorBuddyGroupID = generateUniqueID(&systemTargetMapper, &blackListGroupIDs);
      else
         mirrorBuddyGroupID = generateID(&blackListGroupIDs);

      outBuddyGroupIDs->push_back(mirrorBuddyGroupID);
      outBuddyGroups->push_back(MirrorBuddyGroup(primaryTarget, secondaryTarget) );
      blackListGroupIDs.push_back(mirrorBuddyGroupID);

      numTargets = this->localTargetMapper.getSize();
   }

   if(numTargets == 1)
   { // odd number of targets
      uint16_t lastTarget = findNextTarget(NumNodeID(0) );
      std::string logMessage("Storage target with targetNumID " + StringTk::uintToStr(lastTarget) +
         " unused, because no second target available.");
      std::cout << "[WARNING] " << logMessage << std::endl;
      log.log(Log_WARNING, logMessage);

      retVal = FhgfsOpsErr_INVAL;
   }

   return retVal;
}
